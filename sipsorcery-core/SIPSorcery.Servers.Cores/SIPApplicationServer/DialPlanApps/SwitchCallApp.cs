//-----------------------------------------------------------------------------
// Filename: SwitchCallApp.cs
//
// Description: A two legged call that allows different credentials to be used to an upstream
// UAS.
// 
// History:
// 22 Nov 2006	Aaron Clauson	    Created.
// 24 Apr 2007  Guillaume Bonnet    Add switchboard related functions.
// 17 Apr 2008  Aaron Clauson       Added tracing.
// 04 Oct 2008  Aaron Clauson       Added the use of auth username.
//
// License: 
// This software is licensed under the BSD License http://www.opensource.org/licenses/bsd-license.php
//
// Copyright (c) 2008 Aaron Clauson (aaronc@blueface.ie), Blue Face Ltd, Dublin, Ireland (www.blueface.ie)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that 
// the following conditions are met:
//
// Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
// Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following 
// disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Blue Face Ltd. 
// nor the names of its contributors may be used to endorse or promote products derived from this software without specific 
// prior written permission. 
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
// BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
// IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
// OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
// POSSIBILITY OF SUCH DAMAGE.
//-----------------------------------------------------------------------------

using System;
using System.Data;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using SIPSorcery.SIP;
using SIPSorcery.SIP.App;
using SIPSorcery.Sys;
using Heijden.DNS;
using log4net;

#if UNITTEST
using NUnit.Framework;
#endif

namespace SIPSorcery.Servers
{
    public delegate void SIPSwitchCallAnsweredDelegate(SwitchCallApp sipSwitchCall, SIPResponse answeredResponse);
    public delegate void SIPSwitchCallFailedDelegate(SwitchCallApp sipSwitchCall, string errorMessage);
    public delegate void SIPSwitchCallRingingDelegate(SwitchCallApp sipSwitchCall, SIPResponse ringingResponse);
    
    public class SwitchCallApp
    {
        private const int DNS_LOOKUP_TIMEOUT = 5000;
        private const char OUTBOUNDPROXY_AS_ROUTESET_CHAR = '<';    // If this character exists in the call descriptor OutboundProxy setting it gets treated as a Route set.

        private static ILog logger = AppState.GetLogger("appsvr");
        private static string m_userAgent = SIPConstants.SIP_USERAGENT_STRING;
        private static string m_transportParam = SIPHeaderAncillary.SIP_HEADERANC_TRANSPORT;
        private static char m_customHeadersSeparator = SIPProvider.CUSTOM_HEADERS_SEPARATOR;

        private event SIPMonitorLogDelegate m_statefulProxyLogEvent;

        private SIPTransport m_sipTransport;

        private SIPEndPoint m_localSIPEndPoint;                                 // Host address used in the Contact header for requests generated by this proxy. In dialogue requests from the remote agent will use this address.
        public string Owner { get; private set; }                               // If the UAC is authenticated holds the username of the client.
        public SIPCallDescriptor ForwardedCallStruct { get; private set; }      // Describes the server leg of the call from the sipswitch.
        public UASInviteTransaction ClientTransaction { get; private set; }     // Proxy transaction established with a client making a call out through the switch.
        public UACInviteTransaction ForwardedTransaction { get; private set; }  // Proxy transaction established with the third party server for an outbound switch call leg.
        public IPEndPoint ForwardedEndPoint { get; private set; }               // The destination socket that the forwarded leg of the call was sent to.
        
        private bool m_callCancelled = false;                       // It's possible for the call to be cancelled before the INVITE has been sent. This could occur if a DNS lookup on the server takes a while.
        private bool m_hungupOnCancel = false;                      // Set to true if a call has been cancelled AND and then an Ok response was received AND a BYE has been sent to hang it up. This variable is used to stop another BYE transaction being generated.
        private int m_serverAuthAttempts;                           // Used to determine if credentials for a server leg call fail.
        private SIPNonInviteTransaction m_cancelTransaction;        // If the server call is cancelled this transaction contains the CANCEL in case it needs to be resent.
        private bool m_usingOutboundProxy = false;                  // Set to true if the call descriptor specified an OutboundProxy.
        private IPEndPoint m_systemOutboundProxy;                   // If the system needs to use an outbound proxy for every request this will be set and overrides any user supplied values.

        public event SIPSwitchCallAnsweredDelegate CallAnswered;
        public event SIPSwitchCallFailedDelegate CallFailed;
        public event SIPSwitchCallRingingDelegate CallRinging;

        public static Int64 Created;
        public static Int64 Destroyed;

        public SwitchCallApp(
            SIPTransport sipTransport,
            SIPMonitorLogDelegate statefulProxyLogEvent,
            UASInviteTransaction clientTransaction,
            string username,
            SIPCallDescriptor call,
            IPEndPoint systemOutboundProxy)
        {
            m_sipTransport = sipTransport;
            m_statefulProxyLogEvent = statefulProxyLogEvent;
            ClientTransaction = clientTransaction;
            Owner = username;
            ForwardedCallStruct = call;
            m_systemOutboundProxy = systemOutboundProxy;
        }

        public void Start(object state)
        {
            try
            {
                Created++;
                SIPRequest sipRequest = ClientTransaction.TransactionRequest;

                if (!m_callCancelled)
                {
                    SIPRequest switchServerInvite = GetInviteRequest(ForwardedCallStruct, m_localSIPEndPoint, sipRequest.Body, CallProperties.CreateBranchId(), CallProperties.CreateNewCallId());
                    string lookupHost = null;   // Set if a DNS lookup is requested.

                    // Determine the destination for this request.
                    if (m_systemOutboundProxy != null)
                    {
                        // Using the system outbound proxy only, no additional user routing requirements.
                        ForwardedEndPoint = m_systemOutboundProxy;
                        m_usingOutboundProxy = true;
                    }
                    
                    if (m_systemOutboundProxy != null && ForwardedCallStruct.RouteSet != null && ForwardedCallStruct.RouteSet.IndexOf(OUTBOUNDPROXY_AS_ROUTESET_CHAR) == -1)
                    {
                        // There is a system outbound proxy AND the user has requested their own outbound proxy.
                        // Since the system outbound proxy overrules the user one the user's will be added as a Route.
                        switchServerInvite.Header.Routes.PushRoute(new SIPRoute(ForwardedCallStruct.RouteSet, true));
                    }
                    else if (m_systemOutboundProxy == null && ForwardedCallStruct.RouteSet != null && ForwardedCallStruct.RouteSet.IndexOf(OUTBOUNDPROXY_AS_ROUTESET_CHAR) == -1)
                    {
                        // There is no system outbound proxy but the user has requested their own.
                        try
                        {
                            lookupHost = ForwardedCallStruct.RouteSet;
                            ForwardedEndPoint = SIPTransport.GetHostEndPoint(ForwardedCallStruct.RouteSet, true);
                            m_usingOutboundProxy = true;
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Using outbound proxy of " + ForwardedCallStruct.RouteSet + ".", Owner));
                        }
                        catch
                        {
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Error an outbound proxy value was not recognised in SwitchCall. " + ForwardedCallStruct.RouteSet + ".", Owner));
                        }
                    }

                    // No or invalid outbound proxy, determine the forward destination based on the SIP request.
                    if (ForwardedEndPoint == null)
                    {
                        if (switchServerInvite.Header.Routes == null || switchServerInvite.Header.Routes.Length == 0)
                        {
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Attempting to resolve " + switchServerInvite.URI.Host + ".", Owner));
                        }
                        else
                        {
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Route set for call " + switchServerInvite.Header.Routes.ToString() + ".", Owner));
                        }

                        lookupHost = (switchServerInvite.Header.Routes == null || switchServerInvite.Header.Routes.Length == 0) ? switchServerInvite.URI.Host : switchServerInvite.Header.Routes.TopRoute.Host;
                        ForwardedEndPoint = SIPTransport.GetRequestEndPoint(switchServerInvite, true);
                    }

                    if (ForwardedEndPoint != null)
                    {
                        FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Switching " + sipRequest.URI.CanonicalAddress + "->" + SIPURI.ParseSIPURI(ForwardedCallStruct.Uri).CanonicalAddress + " via " + ForwardedEndPoint + ".", Owner));
                        
                        // Now that we have a destination socket create a new UAC transaction for forwarded leg of the call.
                        ForwardedTransaction = m_sipTransport.CreateUACTransaction(switchServerInvite, ForwardedEndPoint, sipRequest.LocalSIPEndPoint);
                        ForwardedTransaction.CDR.Owner = Owner;
                        ForwardedTransaction.UACInviteTransactionInformationResponseReceived += new SIPTransactionResponseReceivedDelegate(SwitchServerInformationResponseReceived);
                        ForwardedTransaction.UACInviteTransactionFinalResponseReceived += new SIPTransactionResponseReceivedDelegate(SwitchServerFinalResponseReceived);
                        ForwardedTransaction.UACInviteTransactionTimedOut += new SIPTransactionTimedOutDelegate(SwitchServerTimedOut);
                        ForwardedTransaction.TransactionTraceMessage += new SIPTransactionTraceMessageDelegate(TransactionTraceMessage);
                        
                        ForwardedTransaction.SendInviteRequest(ForwardedEndPoint, ForwardedTransaction.TransactionRequest);
                    }
                    else
                    {
                        if (switchServerInvite.Header.Routes == null || switchServerInvite.Header.Routes.Length == 0)
                        {
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Forward leg failed, could not resolve URI host " + SIPURI.ParseSIPURI(ForwardedCallStruct.Uri).Host, Owner));
                        }
                        else
                        {
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Forward leg failed, could not resolve top Route host " + switchServerInvite.Header.Routes.TopRoute.Host, Owner));
                        }

                        CallFailed(this, "unresolvable destination " + lookupHost);
                    }
                }
            }
            catch (Exception excp)
            {
                FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Exception StartNewCall. " + excp.Message, Owner));
                //logger.Error("Exception StartNewCall. " + excp.Message);
                CallFailed(this, excp.Message);
            }
        }

        private void SwitchServerTimedOut(SIPTransaction sipTransaction)
        {
            if (CallFailed != null)
            {
                CallFailed(this, "Timeout, no response from server");
            }
        }

        private void SwitchServerFinalResponseReceived(SIPEndPoint localSIPEndPoint, IPEndPoint remoteEndPoint, SIPTransaction sipTransaction, SIPResponse sipResponse)
        {
            try
            {
                FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Response " + sipResponse.StatusCode + " " + sipResponse.ReasonPhrase + " for " + ForwardedTransaction.TransactionRequest.URI.ToString() + ".", Owner));
                //m_sipTrace += "Received " + DateTime.Now.ToString("dd MMM yyyy HH:mm:ss") + " " + localEndPoint + "<-" + remoteEndPoint + "\r\n" + sipResponse.ToString();

                ForwardedTransaction.UACInviteTransactionInformationResponseReceived -= new SIPTransactionResponseReceivedDelegate(SwitchServerInformationResponseReceived);
                ForwardedTransaction.UACInviteTransactionFinalResponseReceived -= new SIPTransactionResponseReceivedDelegate(SwitchServerFinalResponseReceived);
                ForwardedTransaction.TransactionTraceMessage -= new SIPTransactionTraceMessageDelegate(TransactionTraceMessage);

                if (m_callCancelled && sipResponse.Status == SIPResponseStatusCodesEnum.RequestTerminated)
                {
                    // No action required. Correctly received request terminated on an INVITE we cancelled.
                }
                else if (m_callCancelled)
                {
                    if (m_hungupOnCancel)
                    {
                        FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "A cancelled call to " + ForwardedCallStruct.Uri.ToString() + " has been answered AND has already been hungup, no further action being taken.", Owner));
                    }
                    else
                    {
                        m_hungupOnCancel = true;

                        FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "A cancelled call to " + ForwardedCallStruct.Uri.ToString() + " has been answered, hanging up.", Owner));

                        if (sipResponse.Header.Contact != null && sipResponse.Header.Contact.Count > 0)
                        {
                            SIPURI byeURI = sipResponse.Header.Contact[0].ContactURI;
                            SIPRequest byeRequest = GetByeRequest(sipResponse, byeURI);

                            IPEndPoint byeEndPoint = (m_usingOutboundProxy) ? ForwardedEndPoint : SIPTransport.GetRequestEndPoint(byeRequest, true);

                            if (byeEndPoint != null)
                            {
                                SIPNonInviteTransaction byeTransaction = m_sipTransport.CreateNonInviteTransaction(byeRequest, byeEndPoint, localSIPEndPoint);
                                byeTransaction.SendReliableRequest();
                            }
                            else
                            {
                                FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Could not end BYE on cancelled call as request end point could not be determined " + byeRequest.URI.ToString(), Owner));
                            }
                        }
                        else
                        {
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "No contact header provided on response for cancelled call to " + ForwardedCallStruct.Uri.ToString() + " no further action.", Owner));
                        }
                    }
                }
                else if (sipResponse.Status == SIPResponseStatusCodesEnum.ProxyAuthenticationRequired || sipResponse.Status == SIPResponseStatusCodesEnum.Unauthorised)
                {
                    logger.Debug("AuthReqd Final response " + sipResponse.StatusCode + " " + sipResponse.ReasonPhrase + " for " + ForwardedTransaction.TransactionRequest.URI.ToString() + ".");

                    #region Authenticate client call to third party server.

                    if (!m_callCancelled)
                    {
                        if (ForwardedCallStruct.Password == null || ForwardedCallStruct.Password.Trim().Length == 0)
                        {
                            // No point trying to authenticate if there is no password to use.
                            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Forward leg failed, authentication was requested but no credentials were available.", Owner));
                            CallFailed(this, "Authentication requested when no credentials available");
                        }
                        else if (m_serverAuthAttempts == 0)
                        {
                            m_serverAuthAttempts = 1;

                            // Resend INVITE with credentials.
                            string username = (ForwardedCallStruct.AuthUsername != null && ForwardedCallStruct.AuthUsername.Trim().Length > 0) ? ForwardedCallStruct.AuthUsername : ForwardedCallStruct.Username;
                            AuthorizationRequest authRequest = sipResponse.Header.AuthenticationHeader.AuthRequest;
                            authRequest.SetCredentials(username, ForwardedCallStruct.Password, ForwardedCallStruct.Uri.ToString(), SIPMethodsEnum.INVITE.ToString());

                            SIPRequest authInviteRequest = ForwardedTransaction.TransactionRequest;
                            authInviteRequest.Header.AuthenticationHeader = new SIPAuthenticationHeader(authRequest);
                            authInviteRequest.Header.AuthenticationHeader.AuthRequest.Response = authRequest.Digest;

                            authInviteRequest.Header.Via.TopViaHeader.Branch = CallProperties.CreateBranchId();
                            authInviteRequest.Header.CSeq = authInviteRequest.Header.CSeq + 1;

                            // Create a new UAC transaction to establish the authenticated server call.
                            ForwardedTransaction = m_sipTransport.CreateUACTransaction(authInviteRequest, ForwardedEndPoint, localSIPEndPoint);
                            ForwardedTransaction.CDR.Owner = Owner;
                            ForwardedTransaction.UACInviteTransactionInformationResponseReceived += new SIPTransactionResponseReceivedDelegate(SwitchServerInformationResponseReceived);
                            ForwardedTransaction.UACInviteTransactionFinalResponseReceived += new SIPTransactionResponseReceivedDelegate(SwitchServerFinalResponseReceived);
                            ForwardedTransaction.UACInviteTransactionTimedOut += new SIPTransactionTimedOutDelegate(SwitchServerTimedOut);
                            ForwardedTransaction.TransactionTraceMessage += new SIPTransactionTraceMessageDelegate(TransactionTraceMessage);

                            //logger.Debug("Sending authenticated switchcall INVITE to " + ForwardedCallStruct.Host + ".");
                            ForwardedTransaction.SendInviteRequest(ForwardedEndPoint, authInviteRequest);
                            //m_sipTrace += "Sending " + DateTime.Now.ToString("dd MMM yyyy HH:mm:ss") + " " + localEndPoint + "->" + ForwardedTransaction.TransactionRequest.GetRequestEndPoint() + "\r\n" + ForwardedTransaction.TransactionRequest.ToString();
                        }
                        else
                        {
                            //logger.Debug("Authentication of client call to switch server failed.");
                            CallFailed(this, "Authentication with provided credentials failed");
                        }
                    }

                    #endregion
                }
                else
                {
                    //m_callInProgress = false; // the call is now established
                    //logger.Debug("Final response " + sipResponse.StatusCode + " " + sipResponse.ReasonPhrase + " for " + ForwardedTransaction.TransactionRequest.URI.ToString() + ".");
                    CallAnswered(this, sipResponse);
                }
            }
            catch (Exception excp)
            {
                logger.Error("Exception SwitchServerFinalResponseReceived. " + excp.Message);
            }
        }

        private void SwitchServerInformationResponseReceived(SIPEndPoint localSIPEndPoint, IPEndPoint remoteEndPoint, SIPTransaction sipTransaction, SIPResponse sipResponse)
        {
            logger.Debug("Information response " + sipResponse.StatusCode + " " + sipResponse.ReasonPhrase + " for " + ForwardedTransaction.TransactionRequest.URI.ToString() + ".");
            CallRinging(this, sipResponse);
        }

        public void CancelServerCall()
        {
            try
            {
                m_callCancelled = true;

                // Cancel server call.
                if (ForwardedTransaction == null)
                {
                    FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Cancelling forwarded call leg " + ForwardedCallStruct.Uri.ToString() + ", server transaction has not been created yet no CANCEL request required.", Owner));
                }
                else if (m_cancelTransaction != null)
                {
                    if (m_cancelTransaction.TransactionState != SIPTransactionStatesEnum.Completed)
                    {
                        FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Call " + ForwardedTransaction.TransactionRequest.URI.ToString() + " has already been cancelled once, trying again.", Owner));
                        m_cancelTransaction.SendRequest(m_cancelTransaction.TransactionRequest);
                    }
                    else
                    {
                        FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Call " + ForwardedTransaction.TransactionRequest.URI.ToString() + " has already responded to CANCEL, probably overlap in messages not re-sending.", Owner));
                    }
                }
                else if (ForwardedTransaction.TransactionState == SIPTransactionStatesEnum.Proceeding || ForwardedTransaction.TransactionState == SIPTransactionStatesEnum.Trying)
                {
                    //logger.Debug("Cancelling forwarded call leg, sending CANCEL to " + ForwardedTransaction.TransactionRequest.URI.ToString() + " (transid: " + ForwardedTransaction.TransactionId + ").");
                    FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Cancelling forwarded call leg, sending CANCEL to " + ForwardedTransaction.TransactionRequest.URI.ToString() + ".", Owner));

                    // No reponse has been received from the server so no CANCEL request neccessary, stop any retransmits of the INVITE.
                    ForwardedTransaction.CancelCall();

                    SIPRequest cancelRequest = GetCancelRequest(ForwardedTransaction.TransactionRequest);
                    m_cancelTransaction = m_sipTransport.CreateNonInviteTransaction(cancelRequest, ForwardedEndPoint, ForwardedTransaction.LocalSIPEndPoint);
                    m_cancelTransaction.SendRequest(ForwardedEndPoint, cancelRequest);
                }
                else 
                {
                    // No reponse has been received from the server so no CANCEL request neccessary, stop any retransmits of the INVITE.
                    ForwardedTransaction.CancelCall();
                    FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Cancelling forwarded call leg " + ForwardedCallStruct.Uri.ToString() + ", no response from server has been received so no CANCEL request required.", Owner));
                }
            }
            catch (Exception excp)
            {
                FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.DialPlan, "Exception CancelServerCall. " + excp.Message, Owner));
            }
        }

        private SIPRequest GetInviteRequest(SIPCallDescriptor switchCallStruct, SIPEndPoint localSIPEndPoint, string inviteBody, string branchId, string callId)
        {
            SIPRequest inviteRequest = new SIPRequest(SIPMethodsEnum.INVITE, switchCallStruct.Uri);
            inviteRequest.LocalSIPEndPoint = localSIPEndPoint;

            SIPHeader inviteHeader = new SIPHeader(SIPFromHeader.ParseFromHeader(switchCallStruct.From), SIPToHeader.ParseToHeader(switchCallStruct.To), 1, callId);
            inviteHeader.From.FromTag = CallProperties.CreateNewTag();
            inviteHeader.Contact = SIPContactHeader.ParseContactHeader(localSIPEndPoint.ToSIPURI().ToString());
            inviteHeader.CSeqMethod = SIPMethodsEnum.INVITE;
            inviteHeader.UserAgent = m_userAgent;
            inviteRequest.Header = inviteHeader;

            if (switchCallStruct.RouteSet != null && switchCallStruct.RouteSet.IndexOf(OUTBOUNDPROXY_AS_ROUTESET_CHAR) != -1)
            {
                inviteRequest.Header.Routes = SIPRouteSet.ParseSIPRouteSet(switchCallStruct.RouteSet);
            }

            SIPViaHeader viaHeader = new SIPViaHeader(localSIPEndPoint, branchId);
            inviteRequest.Header.Via.PushViaHeader(viaHeader);
            
            inviteRequest.Body = inviteBody;
            inviteRequest.Header.ContentLength = inviteBody.Length;
            inviteRequest.Header.ContentType = "application/sdp";

            try
            {
                if (switchCallStruct.CustomHeaders != null && switchCallStruct.CustomHeaders.Trim().Length > 0)
                {
                    string[] customerHeadersList = switchCallStruct.CustomHeaders.Split(m_customHeadersSeparator);

                    if (customerHeadersList != null && customerHeadersList.Length > 0)
                    {
                        foreach (string customHeader in customerHeadersList)
                        {
                            if (customHeader.IndexOf(':') == -1)
                            {
                                logger.Debug("Skipping custom header due to missing colon, " + customHeader + ".");
                                continue;
                            }
                            else
                            {
                                string headerName = customHeader.Substring(0, customHeader.IndexOf(':'));
                                if (headerName != null && Regex.Match(headerName.Trim(), "^(Via|From|To|Contact|CSeq|Call-ID|Max-Forwards|Content)$", RegexOptions.IgnoreCase).Success)
                                {
                                    logger.Debug("Skipping custom header due to an non-permitted string in header name, " + customHeader + ".");
                                    continue;
                                }
                                else
                                {
                                    if (headerName == SIPHeaders.SIP_HEADER_USERAGENT)
                                    {
                                        if (customHeader.Length > customHeader.IndexOf(':'))
                                        {
                                            inviteRequest.Header.UserAgent = customHeader.Substring(customHeader.IndexOf(':') + 1);
                                        }
                                    }
                                    else
                                    {
                                        inviteRequest.Header.UnknownHeaders.Add(customHeader.Trim());
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception excp)
            {
                logger.Error("Exception Parsing CustomHeader for GetInviteRequest. " + excp.Message + switchCallStruct.CustomHeaders);
            }

            return inviteRequest;
        }

        private SIPRequest GetCancelRequest(SIPRequest originalRequest)
        {
            SIPRequest cancelRequest = new SIPRequest(SIPMethodsEnum.CANCEL, originalRequest.URI);
            cancelRequest.LocalSIPEndPoint = originalRequest.LocalSIPEndPoint;

            SIPHeader originalHeader = originalRequest.Header;
            SIPHeader cancelHeader = new SIPHeader(originalHeader.From, originalHeader.To, originalHeader.CSeq, originalHeader.CallId);
            cancelRequest.Header = cancelHeader;
            cancelHeader.CSeqMethod = SIPMethodsEnum.CANCEL;
            cancelHeader.Routes = originalHeader.Routes;
            cancelHeader.Via = originalHeader.Via;

            return cancelRequest;
        }

        private SIPRequest GetByeRequest(SIPResponse answeredResponse, SIPURI byeURI)
        {
            SIPRequest byeRequest = new SIPRequest(SIPMethodsEnum.BYE, byeURI);
            byeRequest.LocalSIPEndPoint = answeredResponse.LocalSIPEndPoint;

            SIPFromHeader byeFromHeader = answeredResponse.Header.From;
            SIPToHeader byeToHeader = answeredResponse.Header.To;
            int cseq = answeredResponse.Header.CSeq + 1;

            SIPHeader byeHeader = new SIPHeader(byeFromHeader, byeToHeader, cseq, answeredResponse.Header.CallId);
            byeHeader.CSeqMethod = SIPMethodsEnum.BYE;
            byeRequest.Header = byeHeader;

            byeRequest.Header.Routes = (answeredResponse.Header.RecordRoutes != null) ? answeredResponse.Header.RecordRoutes.Reversed() : null;

            SIPViaHeader viaHeader = new SIPViaHeader(byeRequest.LocalSIPEndPoint, CallProperties.CreateBranchId());
            byeRequest.Header.Via.PushViaHeader(viaHeader);

            return byeRequest;
        }

        private void TransactionTraceMessage(SIPTransaction sipTransaction, string message)
        {
            FireProxyLogEvent(new SIPMonitorControlClientEvent(SIPMonitorServerTypesEnum.StatefulProxy, SIPMonitorEventTypesEnum.SIPTransaction, message, Owner));
        }

        private void FireProxyLogEvent(SIPMonitorEvent monitorEvent)
        {
            if (m_statefulProxyLogEvent != null)
            {
                try
                {
                    m_statefulProxyLogEvent(monitorEvent);
                }
                catch (Exception excp)
                {
                    logger.Error("Exception FireProxyLogEvent StatefulProxyCore. " + excp.Message);
                }
            }
        }

        ~SwitchCallApp()
        {
            Destroyed++;
        }
    }
}
